add2 <- function(x, y) {
x + y
}
add2(3, 5)
above <- function(x, n) {
use <- x > n
x[use]
}
x <- 1:20
above(x, 12)
above <- function(x, n = 10) {
use <- x > n
x[use]
}
above(x)
columnmean <- function(y) {
nc <- ncol(y)
means <- numeric(nc)
for(i in 1:nc) {
means[i] <- mean(y[, i])
}
means
}
columnmean(airquality)
setwd("~/Documents/Coursera/R_Programming/Week_3/Assignment/ProgrammingAssignment2")
?mean
?inverse
?solve
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function() m <<- solve(x)%*%x
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function() m <<- solve(x)%*%x
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
cacheSolve(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function() m <<- solve(x)%*%x
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(x)%*%x
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function() m <<- solve((x)%*%x)
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve((x)%*%x)
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
y = A %*% x
x = B %*% y
B = solve(A)
}
get <- function() x
setinverse <- function() m <<- solve((x)%*%x)
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve((x)%*%x)
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function() x <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(x)
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(x)
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function() m <<- solve(x)%*%x
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function() m <<- solve(x)%*%x
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(x)
m
}
## Return a matrix that is the inverse of 'x'
cacheSolve(amatrix)
## Put comments here that give an overall description of what your
## functions do
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
## CG Note: to get inverse of matrix x... solve(x)%*%x
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
## Return a matrix that is the inverse of 'x'
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
bmatrix = (matrix(c(1,2,3,4), nrow=2, ncol=2))
bmatrix
solve(bmatrix)
## The pair of functions contained here will cache the inverse of
## a matrix.
## The makeCacheMatrix function creates a special "matrix" object
## that can cache its inverse
makeCacheMatrix <- function(x = matrix()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setinverse <- function(solve) m <<- solve
getinverse <- function() m
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
## The cacheSolve function computes the inverse of the special
## "matrix" returned by the makeCacheMatrix function. If the
## inverse has already been calculated, then the cacheSolve
## will retreive the inverse from the cache.
cacheSolve <- function(x, ...) {
m <- x$getinverse()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- solve(data, ...)
x$setinverse(m)
m
}
amatrix = makeCacheMatrix(matrix(c(1,2,3,4), nrow=2, ncol=2))
amatrix$get()
cacheSolve(amatrix)
